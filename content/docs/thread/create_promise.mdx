---
title: thread:create_promise
description: Creates a new promise context
badge: Shared
---

### Syntax

```lua
local ctx = thread:create_promise(exec = false, options = false)
```

<Callout type="info">
Requires execution within a try/catch block to handle exceptions.
</Callout>

### Parameters

| Type | Name | Description |
|------|------|-------------|
| `function` | exec | Function executed post promise initialization |
| `table` | options | Options containing the following fields:<br/>• `async` (bool) - whether to execute asynchronously<br/>• `timeout` (number) - timeout duration in milliseconds |

### Returns

| Type | Name | Description |
|------|------|-------------|
| `promise` or `bool` | ctx | Returns promise context containing the following fields on successful execution:<br/>• `resolve` (function) - callable function to resolve the promise with passed arguments<br/>• `reject` (function) - callable function to reject the promise with passed arguments<br/>or false on failure |

<hr/>

### Callback

```lua
exec([self], resolve, reject)
```

| Type | Name | Description |
|------|------|-------------|
| `thread` | self | Running thread instance incase `options.async` was enabled |
| `function` | resolve | Callable function to resolve the promise with passed arguments |
| `function` | reject | Callable function to reject the promise with passed arguments |

<hr/>

### Example

```lua
--Promise awaited without error handling - will throw error if rejected
local promise = thread:create_promise()

local self = thread:create(function(self)
    local result = {self:await(promise)}
    engine.print("Promise resolved:", table.unpack(result))
end)

self:resume()
timer:create(function()
    promise.resolve("Task completed", 123)
    --promise.reject("Task failed", 456)  --This would cause an unhandled error
end, 5000, 1)
```

```lua
--Promise with try/catch - safely handles both resolve and reject cases
local promise = thread:create_promise()

local self = thread:create(function(self)
    self:try({
        exec = function(self)
            local result = {self:await(promise)}
            engine.print("Promise resolved:", table.unpack(result))
        end,

        catch = function(...)
            engine.print("Promise rejected:", ...)
        end   
    })
end)

self:resume()
timer:create(function()
    --promise.resolve("Task completed", 123)
    promise.reject("Task failed", 456)  --This will be caught and handled
end, 5000, 1)
```